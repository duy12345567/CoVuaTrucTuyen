const express = require("express");
const http = require("http");
const { Server } = require("socket.io");
const { Chess } = require("chess.js");

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
    cors: { origin: "*" },
});

const rooms = {};
const matchQueue = [];
const REJOIN_TIMEOUT = 60000;
const INITIAL_TIME = 900;

// --- Helper Function to get active room details ---
function getActiveRoomsDetails() {
    const activeRoomsList = [];
    for (const roomId in rooms) {
        const room = rooms[roomId];
        if (room && room.players && room.players.length === 2 && room.game && !room.game.isGameOver() && room.players.every(p => p.status === 'connected')) {
            
            let player1Name = room.players.find(p => p.color === 'white')?.id.substring(0, 5) || 'P1';
            let player2Name = room.players.find(p => p.color === 'black')?.id.substring(0, 5) || 'P2';

            activeRoomsList.push({
                id: roomId,
                name: `Ph√≤ng ${roomId.substring(5)} (${player1Name} vs ${player2Name})`,
            });
        }
    }
    return activeRoomsList;
}

// --- Helper Functions for Timer ---
function stopPlayerTimer(roomId) {
    const room = rooms[roomId];
    if (!room) return;
    if (room.timerIntervalId) {
        clearInterval(room.timerIntervalId);
        room.timerIntervalId = null;
    }
    const now = Date.now();
    if (room.turnStartTime && room.turn) {
        const elapsedThisTurn = (now - room.turnStartTime) / 1000;
        const currentPlayer = room.players.find(p => p.id === room.turn);
        if (currentPlayer) {
            if (currentPlayer.color === 'white') {
                room.whiteTime = Math.max(0, room.initialWhiteTime - elapsedThisTurn);
                room.initialWhiteTime = room.whiteTime;
            } else {
                room.blackTime = Math.max(0, room.initialBlackTime - elapsedThisTurn);
                room.initialBlackTime = room.blackTime;
            }
        }
    }
    room.turnStartTime = null;
}

function startPlayerTimer(roomId) {
    const room = rooms[roomId];
    if (!room || room.timerIntervalId || room.game.isGameOver() || !room.turn) {
        return;
    }
    const currentPlayer = room.players.find(p => p.id === room.turn);
    if (!currentPlayer || currentPlayer.status !== 'connected') {
        return;
    }
    const opponent = room.players.find(p => p.id !== room.turn);
    if (!opponent || opponent.status !== 'connected') {
         return;
     }

    room.turnStartTime = Date.now();
    room.timerIntervalId = setInterval(() => {
        const currentRoom = rooms[roomId];
        if (!currentRoom || currentRoom.game.isGameOver() || !currentRoom.turn || currentRoom.timerIntervalId !== room.timerIntervalId) {
            if(currentRoom && currentRoom.timerIntervalId) {
                 clearInterval(currentRoom.timerIntervalId);
                 currentRoom.timerIntervalId = null;
            }
            return;
        }
        const now = Date.now();
        const elapsedThisTurn = (now - currentRoom.turnStartTime) / 1000;
        let timeToUpdate = 0;

        if (currentRoom.turn === currentRoom.players[0].id) { 
            currentRoom.whiteTime = Math.max(0, currentRoom.initialWhiteTime - elapsedThisTurn);
            timeToUpdate = currentRoom.whiteTime;
        } else {
            currentRoom.blackTime = Math.max(0, currentRoom.initialBlackTime - elapsedThisTurn);
            timeToUpdate = currentRoom.blackTime;
        }
        io.to(roomId).emit("timerUpdate", { whiteTime: currentRoom.whiteTime, blackTime: currentRoom.blackTime });
        if (timeToUpdate <= 0) {
            const loserId = currentRoom.turn;
            const winnerId = currentRoom.players.find(p => p.id !== loserId)?.id;
            io.to(roomId).emit("gameOver", { result: "win", winner: winnerId, loser: loserId, reason: "timeout", message: `Ng∆∞·ªùi ch∆°i ${winnerId || 'Kh√¥ng x√°c ƒë·ªãnh'} th·∫Øng do ${loserId} h·∫øt th·ªùi gian!` });
            stopPlayerTimer(roomId);
            io.emit("roomListUpdated", getActiveRoomsDetails()); // C·∫≠p nh·∫≠t khi game k·∫øt th√∫c
        }
    }, 1000);
}


io.on("connection", (socket) => {
    console.log(`üü¢ Ng∆∞·ªùi ch∆°i ƒë√£ k·∫øt n·ªëi: ${socket.id}`);

    // --- Client requests list of active rooms ---
    socket.on("requestActiveRooms", () => {
        console.log(`[${socket.id}] requests active rooms list.`);
        socket.emit("activeRoomsList", getActiveRoomsDetails());
    });

    socket.on("spectateGame", ({ roomId }) => {
        const room = rooms[roomId];
        if (!room) {
            socket.emit("spectateFailed", { reason: "not_found", message: "Ph√≤ng kh√¥ng t·ªìn t·∫°i." });
            return;
        }
        socket.join(roomId);
        console.log(`üëÄ Ng∆∞·ªùi xem ${socket.id} ƒë√£ v√†o ph√≤ng ${roomId}`);
        socket.emit("spectateStarted", {
            roomId,
            fen: room.game.fen(),
            history: room.history,
            turn: room.turn,
            // X√°c ƒë·ªãnh m√†u d·ª±a tr√™n ng∆∞·ªùi ch∆°i ƒë·∫ßu ti√™n n·∫øu c√≥ th·ªÉ, ho·∫∑c m·∫∑c ƒë·ªãnh l√† 'white' cho ng∆∞·ªùi xem
            color: room.players[0]?.color || 'white', // Ng∆∞·ªùi xem s·∫Ω th·∫•y b√†n c·ªù theo h∆∞·ªõng c·ªßa qu√¢n tr·∫Øng
            whiteTime: room.whiteTime,
            blackTime: room.blackTime,
        });
    });

    socket.on("startMatch", () => {
        console.log(`üë§ Ng∆∞·ªùi ch∆°i ${socket.id} b·∫Øt ƒë·∫ßu t√¨m tr·∫≠n`);
        if (matchQueue.some(player => player.id === socket.id) || Object.values(rooms).some(room => room.players.some(p => p.currentSocketId === socket.id && p.status === 'connected'))) {
             return;
        }
        matchQueue.push(socket);

        if (matchQueue.length >= 2) {
            const player1Socket = matchQueue.shift();
            const player2Socket = matchQueue.shift();
            if (!player1Socket.connected || !player2Socket.connected) {
                 if (player1Socket.connected) matchQueue.unshift(player1Socket);
                 if (player2Socket.connected) matchQueue.unshift(player2Socket);
                 return;
            }

            const roomId = `room_${Date.now()}`;
            const player1 = { id: player1Socket.id, currentSocketId: player1Socket.id, color: 'white', status: 'connected' };
            const player2 = { id: player2Socket.id, currentSocketId: player2Socket.id, color: 'black', status: 'connected' };

            rooms[roomId] = {
                roomId: roomId,
                players: [player1, player2],
                game: new Chess(),
                history: [],
                turn: player1.id,
                whiteTime: INITIAL_TIME, blackTime: INITIAL_TIME,
                initialWhiteTime: INITIAL_TIME, initialBlackTime: INITIAL_TIME,
                turnStartTime: null, timerIntervalId: null,
                rejoinTimeoutId: {}, playerStatus: { [player1.id]: 'connected', [player2.id]: 'connected' },
                disconnectTime: {}
            };

            player1Socket.join(roomId);
            player2Socket.join(roomId);
            console.log(`üéâ Gh√©p c·∫∑p th√†nh c√¥ng! Ph√≤ng ${roomId}: ${player1.id} (Tr·∫Øng) vs ${player2.id} (ƒêen)`);

            player1Socket.emit("gameStart", { color: player1.color, turn: rooms[roomId].turn, roomId, playerToken: player1.id, whiteTime: INITIAL_TIME, blackTime: INITIAL_TIME });
            player2Socket.emit("gameStart", { color: player2.color, turn: rooms[roomId].turn, roomId, playerToken: player2.id, whiteTime: INITIAL_TIME, blackTime: INITIAL_TIME });

            startPlayerTimer(roomId);
            io.emit("roomListUpdated", getActiveRoomsDetails()); // C·∫≠p nh·∫≠t khi c√≥ ph√≤ng m·ªõi
        }
    });

    socket.on("cancelMatch", () => {
        console.log(`üë§ Ng∆∞·ªùi ch∆°i ${socket.id} h·ªßy t√¨m tr·∫≠n`);
        const index = matchQueue.findIndex(player => player.id === socket.id);
        if (index !== -1) matchQueue.splice(index, 1);
    });

    socket.on("move", ({ roomId, move }) => {
        const room = rooms[roomId];
        if (!room || room.game.isGameOver()) return;
        const player = room.players.find(p => p.currentSocketId === socket.id);
        if (!player || player.id !== room.turn) return;
        const opponent = room.players.find(p => p.id !== player.id);
        if (opponent && opponent.status === 'disconnected') {
             socket.emit("opponentStillDisconnected", { message: "ƒê·ªëi th·ªß ƒëang t·∫°m th·ªùi ng·∫Øt k·∫øt n·ªëi, vui l√≤ng ƒë·ª£i." });
             return;
        }

        stopPlayerTimer(roomId);
        const game = room.game;
        const validMoveResult = game.move(move);

        if (validMoveResult === null) {
            socket.emit("invalidMove", { move, message: "N∆∞·ªõc ƒëi kh√¥ng h·ª£p l·ªá!" });
            startPlayerTimer(roomId); // Restart timer cho ng∆∞·ªùi ƒëi sai
            return;
        }

        room.history.push(validMoveResult);
        const fen = game.fen();
        io.to(roomId).emit("opponentMove", { move: validMoveResult, fen });

        let gameOverHandled = false;
        if (game.isCheckmate()) {
             const winnerId = opponent.id;
             const loserId = player.id;
             io.to(roomId).emit("gameOver", { result: "win", winner: winnerId, loser: loserId, reason: "checkmate", message: `Ng∆∞·ªùi ch∆°i ${winnerId} th·∫Øng do chi·∫øu h·∫øt!` });
             gameOverHandled = true;
         } else if (game.isStalemate() || game.isDraw() || game.isInsufficientMaterial()) {
             io.to(roomId).emit("gameOver", { result: "draw", reason: game.isStalemate() ? "stalemate" : game.isInsufficientMaterial() ? "insufficient material" : "draw", message: "V√°n c·ªù h√≤a!" });
             gameOverHandled = true;
         }

        if (!gameOverHandled) {
            room.turn = opponent.id;
            if(opponent.color === 'white'){ room.initialWhiteTime = room.whiteTime; }
            else { room.initialBlackTime = room.blackTime; }
            io.to(roomId).emit("updateTurn", { turn: room.turn });
            startPlayerTimer(roomId);
        } else {
            stopPlayerTimer(roomId);
            Object.values(room.rejoinTimeoutId).forEach(clearTimeout);
            room.rejoinTimeoutId = {};
            io.emit("roomListUpdated", getActiveRoomsDetails()); // C·∫≠p nh·∫≠t khi game k·∫øt th√∫c
        }
    });

    socket.on("rejoinGame", ({ roomId, playerToken }) => {
        const room = rooms[roomId];
        if (!room) { socket.emit("rejoinFailed", { reason: "room_not_found", message: "Ph√≤ng kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ k·∫øt th√∫c." }); return; }
        const player = room.players.find(p => p.id === playerToken);
        if (!player) { socket.emit("rejoinFailed", { reason: "invalid_token", message: "Th√¥ng tin ng∆∞·ªùi ch∆°i kh√¥ng h·ª£p l·ªá." }); return; }

        if (player.status !== 'disconnected') {
             if (player.currentSocketId !== socket.id) { player.currentSocketId = socket.id; socket.join(roomId); }
             const opponent = room.players.find(p => p.id !== player.id);
              socket.emit("gameRejoined", {
                   color: player.color, turn: room.turn, roomId, playerToken: player.id,
                   fen: room.game.fen(), history: room.history,
                   whiteTime: room.whiteTime, blackTime: room.blackTime,
                   opponentStatus: opponent?.status ?? 'unknown'
               });
             return;
         }

        const disconnectTime = room.disconnectTime[player.id];
        if (disconnectTime && (Date.now() - disconnectTime > REJOIN_TIMEOUT)) {
             socket.emit("rejoinFailed", { reason: "timeout_expired", message: "ƒê√£ h·∫øt th·ªùi gian ch·ªù ƒë·ªÉ k·∫øt n·ªëi l·∫°i." });
              if (rooms[roomId]) { 
                   const winner = room.players.find(p => p.id !== player.id);
                   io.to(roomId).emit("gameOver", { result: "win", winner: winner?.id, loser: player.id, reason: "abandoned", message: `Ng∆∞·ªùi ch∆°i ${winner?.id || 'Kh√¥ng x√°c ƒë·ªãnh'} th·∫Øng do ${player.id} tho√°t tr·∫≠n!` });
                   stopPlayerTimer(roomId); delete rooms[roomId];
                   io.emit("roomListUpdated", getActiveRoomsDetails()); // C·∫≠p nh·∫≠t khi ph√≤ng b·ªã x√≥a
              }
             return;
         }

        if (room.rejoinTimeoutId[player.id]) { clearTimeout(room.rejoinTimeoutId[player.id]); delete room.rejoinTimeoutId[player.id]; }
        player.status = 'connected'; player.currentSocketId = socket.id; room.playerStatus[player.id] = 'connected'; delete room.disconnectTime[player.id];
        socket.join(roomId);
        const opponent = room.players.find(p => p.id !== player.id);
        socket.emit("gameRejoined", {
            color: player.color, turn: room.turn, roomId, playerToken: player.id,
            fen: room.game.fen(), history: room.history,
            whiteTime: room.whiteTime, blackTime: room.blackTime,
            opponentStatus: opponent?.status ?? 'unknown'
        });
        if (opponent && opponent.status === 'connected') {
            io.to(opponent.currentSocketId).emit("playerReconnected", { reconnectedPlayerId: player.id });
            startPlayerTimer(roomId); // Kh·ªüi ƒë·ªông l·∫°i timer n·∫øu c·∫£ 2 ƒë√£ k·∫øt n·ªëi
        }
         io.emit("roomListUpdated", getActiveRoomsDetails()); // C·∫≠p nh·∫≠t danh s√°ch ph√≤ng khi c√≥ ng∆∞·ªùi rejoin
    });

    socket.on("disconnect", (reason) => {
        console.log(`üî¥ Ng∆∞·ªùi ch∆°i ng·∫Øt k·∫øt n·ªëi: ${socket.id}. L√Ω do: ${reason}`);
        const queueIndex = matchQueue.findIndex(player => player.id === socket.id);
        if (queueIndex !== -1) matchQueue.splice(queueIndex, 1);

        let roomIdFound = null; let playerInfo = null;
        for (const id in rooms) {
             const room = rooms[id];
             const playerIndex = room.players.findIndex(p => p.currentSocketId === socket.id);
              if (playerIndex !== -1) { roomIdFound = id; playerInfo = room.players[playerIndex]; break; }
         }

        if (roomIdFound && playerInfo) {
            const room = rooms[roomIdFound];
            let roomListNeedsUpdate = false;

            if (!room.game.isGameOver() && playerInfo.status === 'connected') {
                 playerInfo.status = 'disconnected'; room.playerStatus[playerInfo.id] = 'disconnected'; room.disconnectTime[playerInfo.id] = Date.now();
                 stopPlayerTimer(roomIdFound);
                 roomListNeedsUpdate = true; 

                 const opponent = room.players.find(p => p.id !== playerInfo.id);
                 if (opponent && opponent.status === 'connected') {
                    io.to(opponent.currentSocketId).emit("opponentDisconnected", { disconnectedPlayerId: playerInfo.id });
                 }

                 if (!room.rejoinTimeoutId[playerInfo.id]) {
                      room.rejoinTimeoutId[playerInfo.id] = setTimeout(() => {
                            const currentRoom = rooms[roomIdFound]; if (!currentRoom) return;
                             if (currentRoom.playerStatus[playerInfo.id] === 'disconnected') {
                                 const winner = currentRoom.players.find(p => p.id !== playerInfo.id);
                                 io.to(roomIdFound).emit("gameOver", { result: "win", winner: winner?.id, loser: playerInfo.id, reason: "abandoned", message: `Ng∆∞·ªùi ch∆°i ${winner?.id || 'Kh√¥ng x√°c ƒë·ªãnh'} th·∫Øng do ${playerInfo.id} tho√°t tr·∫≠n!` });
                                 stopPlayerTimer(roomIdFound); delete currentRoom.rejoinTimeoutId[playerInfo.id]; delete rooms[roomIdFound];
                                 io.emit("roomListUpdated", getActiveRoomsDetails()); // C·∫≠p nh·∫≠t khi ph√≤ng b·ªã x√≥a
                             } else { delete currentRoom.rejoinTimeoutId[playerInfo.id]; }
                       }, REJOIN_TIMEOUT);
                  }
            } else if (playerInfo.status === 'connected') {
                 playerInfo.status = 'disconnected'; room.playerStatus[playerInfo.id] = 'disconnected'; room.disconnectTime[playerInfo.id] = Date.now();
                 roomListNeedsUpdate = true;
            }

            const allPlayersInRoomDisconnected = room.players.every(p => p.status === 'disconnected');
            if (allPlayersInRoomDisconnected) {
                roomListNeedsUpdate = true;
            }

            if(roomListNeedsUpdate){
                io.emit("roomListUpdated", getActiveRoomsDetails());
            }

        }
    });

    socket.on("sendMessage", ({ roomId, message }) => {
         const room = rooms[roomId]; if (!room) return; const senderPlayer = room.players.find(p => p.currentSocketId === socket.id); if (!senderPlayer) return;
          const opponent = room.players.find(p => p.id !== senderPlayer.id);
          if (opponent && opponent.status === 'connected') { io.to(opponent.currentSocketId).emit("receiveMessage", { sender: senderPlayer.id, message: message.message }); }
    });
});

setInterval(() => {
     const now = Date.now();
     let updated = false;
     for (let roomId in rooms) {
         const room = rooms[roomId];
         let shouldDelete = false;
         const allPlayersReallyDisconnected = room.players.every(p => room.playerStatus[p.id] === 'disconnected');

         if (room.game.isGameOver()) {
             if (allPlayersReallyDisconnected) {
                 const lastDisconnectTime = Math.max(0, ...Object.values(room.disconnectTime).filter(t => t != null));
                 if (now - (lastDisconnectTime || room.game.startTime || 0) > 120000) { // 2 ph√∫t
                     console.log(`[${roomId}] D·ªçn ph√≤ng c≈© (game over, all disconnected > 2 mins).`);
                     shouldDelete = true;
                 }
             } else if (room.players.length === 0) { 
                shouldDelete = true;
             }
         } else { 
            if (allPlayersReallyDisconnected) {
                const creationOrLastActivityTime = room.turnStartTime || parseInt(roomId.split('_')[1]) || 0;
                if (now - creationOrLastActivityTime > 600000) { 
                     console.log(`[${roomId}] D·ªçn ph√≤ng k·∫πt (ko game over, all disconnected > 10 mins inactivity).`);
                     shouldDelete = true;
                }
            }
         }

         if (shouldDelete) {
             stopPlayerTimer(roomId);
             Object.values(room.rejoinTimeoutId || {}).forEach(clearTimeout);
             delete rooms[roomId];
             updated = true;
         }
     }
      if(updated) {
          console.log(`Cleanup task finished. Some rooms might have been deleted.`);
          io.emit("roomListUpdated", getActiveRoomsDetails());
      }
 }, 120000); // Ch·∫°y m·ªói 2 ph√∫t

server.listen(5000, "0.0.0.0", () => {
    console.log("üöÄ M√°y ch·ªß ƒëang ch·∫°y tr√™n c·ªïng 5000");
});